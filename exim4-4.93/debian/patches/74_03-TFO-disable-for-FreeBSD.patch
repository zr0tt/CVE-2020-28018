From 0582221c4a875e35b5ccefe9a17eef584819e4f0 Mon Sep 17 00:00:00 2001
From: "Heiko Schlittermann (HS12-RIPE)" <hs@schlittermann.de>
Date: Tue, 10 Dec 2019 23:14:35 +0100
Subject: [PATCH 3/7] TFO: disable for FreeBSD

(cherry-picked from 52503083b9eded01c25e1c73f4510963c3cee799)
---
 src/ip.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/ip.c b/src/ip.c
index 19be51a03..70e3e2064 100644
--- a/src/ip.c
+++ b/src/ip.c
@@ -245,7 +245,7 @@ callout_address = string_sprintf("[%s]:%d", address, port);
 sigalrm_seen = FALSE;
 if (timeout > 0) ALARM(timeout);
 
-#ifdef TCP_FASTOPEN
+#if defined(TCP_FASTOPEN) && (defined(MSG_FASTOPEN) || defined(EXIM_TFO_CONNECTX))
 /* TCP Fast Open, if the system has a cookie from a previous call to
 this peer, can send data in the SYN packet.  The peer can send data
 before it gets our ACK of its SYN,ACK - the latter is useful for
@@ -255,8 +255,8 @@ possibly use the data-on-syn, so support that too. */
 if (fastopen_blob && f.tcp_fastopen_ok)
   {
 # ifdef MSG_FASTOPEN
-  /* This is a Linux implementation.  It might be useable on FreeBSD; I have
-  not checked. */
+  /* This is a Linux implementation.  FreeBSD does not seem to have MSG_FASTOPEN so
+  how to get TFO is unknown. */
 
   if ((rc = sendto(sock, fastopen_blob->data, fastopen_blob->len,
 		    MSG_FASTOPEN | MSG_DONTWAIT, s_ptr, s_len)) >= 0)
-- 
2.24.0

