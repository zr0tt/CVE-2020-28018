From da5bc28fbc92521e5fe5ab65a8bce1a10610b70c Mon Sep 17 00:00:00 2001
From: Jeremy Harris <jgh146exb@wizmail.org>
Date: Wed, 26 Feb 2020 10:54:56 +0000
Subject: [PATCH 28/28] Fix ${tr } expansion item.  Bug 2533

Broken-by: acec9514b1
(cherry picked from commit 03f110c5d92f3c8aa9dc447253a33e9c039a78b0)
---
 doc/ChangeLog |  4 ++++
 src/expand.c      | 19 ++++++++++---------
 2 files changed, 14 insertions(+), 9 deletions(-)

diff --git a/doc/ChangeLog b/doc/ChangeLog
index d9833c8e1..e46e8c694 100644
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -74,6 +74,10 @@ JH/25 Fix use of concurrent TLS connections under GnuTLS.  When a callout was
       used rather than per-connection info for tracking the state of data
       queued for transmission.  This could result in a connection hang.
 
+JH/28 Bug 2533: Fix expansion of ${tr } item.  When called in some situations
+      it could crash from a null-deref.  This could also affect the
+      ${addresses: } operator and ${readsock } item.
+
 
 Exim version 4.93
 -----------------
diff --git a/src/expand.c b/src/expand.c
index 21686e99c..dea26494a 100644
--- a/src/expand.c
+++ b/src/expand.c
@@ -5029,7 +5029,7 @@ while (*s != 0)
       {
       client_conn_ctx cctx;
       int timeout = 5;
-      int save_ptr = yield->ptr;
+      int save_ptr = yield ? yield->ptr : 0;
       FILE * fp = NULL;
       uschar * arg;
       uschar * sub_arg[4];
@@ -5262,7 +5262,7 @@ while (*s != 0)
 
         if (sigalrm_seen)
           {
-          yield->ptr = save_ptr;
+          if (yield) yield->ptr = save_ptr;
           expand_string_message = US "socket read timed out";
           goto SOCK_FAIL;
           }
@@ -5429,7 +5429,7 @@ while (*s != 0)
 
     case EITEM_TR:
       {
-      int oldptr = yield->ptr;
+      int oldptr = yield ? yield->ptr : 0;
       int o2m;
       uschar *sub[3];
 
@@ -6170,7 +6170,7 @@ while (*s != 0)
     case EITEM_REDUCE:
       {
       int sep = 0;
-      int save_ptr = yield->ptr;
+      int save_ptr = yield ? yield->ptr : 0;
       uschar outsep[2] = { '\0', '\0' };
       const uschar *list, *expr, *temp;
       uschar *save_iterate_item = iterate_item;
@@ -6317,7 +6317,8 @@ while (*s != 0)
         item of the output list, add in a space if the new item begins with the
         separator character, or is an empty string. */
 
-        if (yield->ptr != save_ptr && (temp[0] == *outsep || temp[0] == 0))
+        if (  yield && yield->ptr != save_ptr
+	   && (temp[0] == *outsep || temp[0] == 0))
           yield = string_catn(yield, US" ", 1);
 
         /* Add the string in "temp" to the output list that we are building,
@@ -6357,7 +6358,7 @@ while (*s != 0)
       the redundant final separator. Even though an empty item at the end of a
       list does not count, this is tidier. */
 
-      else if (yield->ptr != save_ptr) yield->ptr--;
+      else if (yield && yield->ptr != save_ptr) yield->ptr--;
 
       /* Restore preserved $item */
 
@@ -7222,7 +7223,7 @@ while (*s != 0)
         {
         uschar outsep[2] = { ':', '\0' };
         uschar *address, *error;
-        int save_ptr = yield->ptr;
+        int save_ptr = yield ? yield->ptr : 0;
         int start, end, domain;  /* Not really used */
 
         while (isspace(*sub)) sub++;
@@ -7253,7 +7254,7 @@ while (*s != 0)
 
           if (address)
             {
-            if (yield->ptr != save_ptr && address[0] == *outsep)
+            if (yield && yield->ptr != save_ptr && address[0] == *outsep)
               yield = string_catn(yield, US" ", 1);
 
             for (;;)
@@ -7282,7 +7283,7 @@ while (*s != 0)
         /* If we have generated anything, remove the redundant final
         separator. */
 
-        if (yield->ptr != save_ptr) yield->ptr--;
+        if (yield && yield->ptr != save_ptr) yield->ptr--;
         f.parse_allow_group = FALSE;
         continue;
         }
-- 
2.25.1

